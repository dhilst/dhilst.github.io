---
layout: post
title: What about take any byte of an int in a char variable?
date: '2009-12-16T08:22:00.000-08:00'
author: Daniel Hilst
blogger: true
tags: 
modified_time: '2009-12-16T08:28:18.698-08:00'
blogger_id: tag:blogger.com,1999:blog-8785437776394405849.post-5555437881476413572
blogger_orig_url: http://gkos-hw.blogspot.com/2009/12/what-about-take-any-byte-of-int-in-char.html
---

here is <br /><pre class="nerd" >;;; file dwordtobyte.asm<br />segment .text<br />  global lwordhbyte, lwordlbyte, hwordhbyte, hwordlbyte, bytestodword<br />lwordhbyte:<br />;;;<br />;;; unsigned char lwordhbyte (unsigned int dword)<br />;;; return a byte containing the 0x0000FF00 bits of dword<br />;;; <br />  enter  0,0<br />  push  ebx<br /><br />  mov  eax, [ebp + 8] ; first argument<br />  rol  ax, 8<br />  and  eax, 0x000000FF<br /><br />  pop  ebx<br />  leave<br />  ret<br /><br />segment .text<br />lwordlbyte:<br />;;;<br />;;; unsigned char lwordlbyte (unsigned int dword)<br />;;; return a byte containing the 0x000000XX bits of dword<br />;;; <br />  enter 0,0<br />  push ebx<br /><br />  mov  eax, [ebp + 8] ; first argument<br />  and  eax, 0x000000FF<br /><br />  pop  ebx<br />  leave<br />  ret<br /><br />hwordlbyte:<br />;;; <br />;;; unsigned char hwordlbyte (unsigned int dword)<br />;;; return a byte contaning the 0x00XX0000 bits of dword<br />;;; <br />  enter  0, 0<br />  push ebx<br />  <br />  mov  eax, [ebp + 8]<br />  rol  eax, 16   ; 0x00XX0000 -> 0x000000XX<br />  and  eax, 0x000000FF ; let only the lower 8 bits on<br /><br />  pop  ebx<br />  leave<br />  ret<br /><br />hwordhbyte:<br />;;;<br />;;; unsgined char hwordhbyte (unsigned int dword)<br />;;; return a byte containing the 0xXX000000 bits of dword<br />;;; <br />  enter 0,0<br />  push ebx<br /><br />  mov  eax, [ebp + 8]<br />  rol  eax, 16   ; 0xXX000000 -> 0x0000XX00<br />  rol  ax,  8   ; 0x0000XX00 -> 0x000000XX<br />  and  eax, 0x000000FF<br /><br />  pop  ebx<br />  leave<br />  ret<br /><br />bytestodword:<br />;;;<br />;;; unsgined int bytestodword (unsigned char HH, unsigned char HL<br />;;;                  unsigned char LH, unsigned char LL)<br />;;; return an dword made by its four arguments<br />;;; in this fashion 0xHHHLLHLL<br />;;; <br />  enter  0,0<br />  push ebx<br />        ; High word  <br />  mov  ah, [ebp + 8] ; 0x0000XX00 <br />  mov  al, [ebp + 12] ; 0x000000XX<br />  rol  eax, 16   ; 0x0000XXXX -> 0xXXXX0000<br /><br />        ; Low word <br />  mov  ah, [ebp + 16] ; 0x0000XX00<br />  mov  al, [ebp + 20] ; 0x000000XX<br /><br />  pop  ebx<br />  leave<br />  ret<br /></pre>and a little test<br /><pre class="brush: cpp">/* file driver.c */<br />#include &lt;stdio.h&gt;<br />#include &lt;stdlib.h&gt;<br /><br />/*<br /> * functions from dword2byte.o file<br /> */<br />unsigned char lwordhbyte  (unsigned int);<br />unsigned char lwordlbyte  (unsigned int);<br />unsigned char hwordlbyte  (unsigned int);<br />unsigned char hwordhbyte  (unsigned int);<br />unsigned int  bytestoword (unsigned char, unsigned char, <br />         unsigned char, unsigned char);<br /><br />int<br />main (void)<br />{<br />  unsigned int num = 0xFF0a5040, /* 255 10 80 64 */<br /> newnum;<br />  unsigned char HH, HL, LH, LL;<br /><br />  HH = hwordhbyte (num);<br />  HL = hwordlbyte (num);<br />  LH = lwordhbyte (num);<br />  LL = lwordlbyte (num);<br />  newnum = bytestodword (HH, HL, LH, LL);<br />  printf ("bytes values of num %d %d %d %d (in decimal)\n", <br />    HH, HL, LH, LL);<br />  printf ("dword value of newnum %x (in hex)\n", newnum);<br /><br />  return 0;<br />}<br /></pre><br />Compiling:<br />nasm -f elf dwordtobyte.asm<br />gcc -o bytesfun driver.c dwordtobyte.o