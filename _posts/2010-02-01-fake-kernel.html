---
layout: post
title: Fake kernel ..
date: '2010-02-01T16:02:00.000-08:00'
author: Daniel Hilst
blogger: true
tags: 
modified_time: '2010-02-01T16:12:48.047-08:00'
blogger_id: tag:blogger.com,1999:blog-8785437776394405849.post-8253178224001110065
blogger_orig_url: http://gkos-hw.blogspot.com/2010/02/fake-kernel.html
---

This is the implementations of <a href="http://www.iu.hio.no/%7Emark/os/os.html#SECTION00580000000000000000"> this</a> and I know,<br />it's realy bad coded .. <br /><br />files:<br />common.c -&gt; common functions<br />scheduler.c -&gt; scheduler functions<br />process.c -&gt; process functions<br />filequeue.c -&gt; queue functions<br />fakek.h -&gt; where all stuff is declared <br />main.c -&gt; the main program<br />Makefile -&gt; the make file :P<br /><br /><pre class="brush:c">/*<br /> * file: common.c<br /> */<br />#include &lt;dirent.h&gt;<br />#include &lt;stdlib.h&gt;<br />#include &lt;string.h&gt;<br /><br />void *<br />xmalloc (size_t size)<br />{<br />  void * pool = malloc (size);<br />  if (pool == NULL)<br /> err (1, "xmalloc");<br />  return pool;<br />}<br /><br />DIR *<br />xopendir (const char * dirname)<br />{<br />  DIR * dp = opendir (dirname);<br />  if (dp == NULL)<br /> err (1, "xopendir");<br />  return dp;<br />}<br /><br />int <br />xopen (const char * filename, int state, mode_t mode)<br />{<br />  int fd = open (filename, state, mode);<br />  if (fd == -1)<br /> err (1, "xopen\n");<br />  return fd;<br />}<br /><br />char * <br />create_filepath (const char * dir, const char * file)<br />{<br />  char * path = (char *) xmalloc ((size_t) strlen (dir) + strlen (file) +1);<br />  memset (path, 0, strlen (dir) + strlen (file) +1);<br />  strncpy (path, dir, strlen (dir));<br />  strncat (path, file, strlen (file));<br />  return path;<br />}<br /><br />void xrename (const char * old, const char * new)<br />{<br />  int rval = rename (old, new);<br />  if (rval == -1)<br /> err (1, "xrename");<br />}<br /><br /></pre><br /><pre class="brush:c">/*<br /> * file scheduler.c<br /> */<br />#include "fakek.h"<br /><br /><br />queue_type QBuffer;<br />const char * userdir = "./fstack/User/";<br />const char * sysdir = "./fstack/System/";<br />const char * rdir = "./fstack/Running/";  <br /><br />/* Save function to queue process */<br />void <br />Sched_writebuf (unsigned int pid, unsigned int state, unsigned int fork,<br />    unsigned int stopline, unsigned int spendtime,<br />    unsigned int priority, char * filename)<br />{<br />  /* Write here */<br />  QBuffer.proc.pid = pid;<br />  QBuffer.proc.state = state;<br />  QBuffer.proc.fork = fork;<br />  QBuffer.proc.stopline = stopline;<br />  QBuffer.proc.spendtime = spendtime;<br />  QBuffer.proc.priority = priority;<br />  //  QBuffer.proc.filename = (char *) xmalloc (strlen (filename) + 1);<br />  /* This will be freed with q_read() */<br />  strncpy (QBuffer.proc.filename, filename, strlen (filename));<br />  QBuffer.proc.filename [strlen (filename)] = '\0';<br />  /* Send to Queue, the q_write increments QSize */<br />  q_write (&amp; QBuffer);<br />}<br />  <br /><br />/* <br /> * return a regular file entry <br /> * consecutive calls return consecutive file entries <br /> * it uses Scheddir poiter, that must be a non-NULL pointer<br /> * otherwise the behavior is undefined <br /> */<br />struct dirent *<br />Sched_getrfile (DIR * dirp)<br />{<br />  struct dirent * entry_ptr;<br />  while (entry_ptr = readdir (dirp))<br /> if (entry_ptr-&gt;d_type &amp; DT_REG)<br />   return entry_ptr;<br />  /* There is no regular files in this diretory */ <br />  return NULL;<br />}<br /><br /><br />/* This is the scheduler itself */ <br />void *<br />Scheduler_thread (void * unused)<br />{<br />  struct timespec time = { 0, 1000 };<br />  struct dirent * entry_ptr;<br />  int sys_switch;<br />  char * snew, * sold;<br />  DIR * tmpdir_ptr;<br />  /* While forever */<br />  while (1) {<br /> /* Search first for System process after User process */ <br /> sys_switch = 0;<br /> while (1) {<br />   pthread_mutex_lock (&amp;mutex);<br />   printf ("SCHEDULER LOOP START\n");<br />   /* open system dir */<br />   tmpdir_ptr = xopendir (sysdir);<br />   entry_ptr = Sched_getrfile (tmpdir_ptr);<br />   closedir (tmpdir_ptr);<br />   if (entry_ptr != NULL) {<br />  /* We got one system process */<br />  sys_switch++;<br />  pthread_mutex_unlock (&amp;mutex);<br />  break;<br />   }<br />   /* open user dir */<br />   tmpdir_ptr = xopendir (userdir);<br />   entry_ptr = Sched_getrfile (tmpdir_ptr);<br />   closedir (tmpdir_ptr);<br />   if (entry_ptr != NULL) {<br />  /* We got one user process */<br />  pthread_mutex_unlock (&amp;mutex);<br />  break;<br />   }<br />   /* There is no more process */<br />   sleep (1);<br />   printf ("SCHEDULER LOOP /* NO NEW PROCESS */\n");<br />   pthread_mutex_unlock (&amp;mutex);<br />   /* Wait 1000 nanoseconds to search again */<br />   nanosleep (&amp;time, NULL);<br /> } <br /> pthread_mutex_lock (&amp;mutex);<br /> sleep (1);<br /> printf ("\E[31mNew process arise: %s\n\E[0m", entry_ptr-&gt;d_name);<br /> sleep (1);<br /> if (sys_switch) {<br />   sold = create_filepath (sysdir, entry_ptr-&gt;d_name);<br />   snew = create_filepath (rdir, entry_ptr-&gt;d_name);<br />   printf ("\E[31mmoving %s -&gt; %s\n\E[0m", sold, snew);<br />   sleep (1);<br />   rename (sold, snew);<br />   free (sold);<br />   free (snew);<br />   printf ("\E[31mScheduling system proc Pid:%d\n\E[0m", 10 + PidCounter);<br />   sleep (1);<br />   /* pid, state, fork, stopline, spendtime, priority, filename */<br />   Sched_writebuf (10 + PidCounter, 0, 0, 1, 0, 4, entry_ptr-&gt;d_name);<br />   PidCounter++;<br />   printf ("\E[31mQueueSize = %d\n\E[0m", QSize);<br />   sleep (1);<br /> }<br /> else {<br />   sold = create_filepath (userdir, entry_ptr-&gt;d_name);<br />   snew = create_filepath (rdir, entry_ptr-&gt;d_name);<br />   sleep (1);<br />   printf ("\E[31mmoving %s -&gt; %s\n\E[0m", sold, snew);<br />   rename (sold, snew);<br />   free (sold);<br />   free (snew);<br />   sleep (1);<br />   printf ("\E[32mScheduling it Pid:%d\n\E[0m", 10 + PidCounter);<br />   /* pid, state, fork, stopline, spendtime, priority, filename */<br />   Sched_writebuf (10 + PidCounter, 0, 0, 1, 0, 1, entry_ptr-&gt;d_name);<br />   PidCounter++;<br />   sleep (1);<br />   printf ("\E[32mQueueSize = %d\n\E[0m", QSize);<br /> }<br /> sleep (1);<br /> printf ("SCHEDULER LOOP FINISH\n");<br /> pthread_mutex_unlock (&amp;mutex);         <br /> nanosleep (&amp;time, NULL);<br />  }<br />}<br /></pre><br /><pre class="brush:c">/*<br /> * file: process.c<br /> */<br />#define MAXPIDNUM 99<br />#define THREADMAXNANOTIME 1000<br />#include "fakek.h"<br /><br />queue_type PBuffer;<br />pthread_mutex_t Proc_readbuf_mutex = PTHREAD_MUTEX_INITIALIZER;<br />unsigned int MaxTime;<br />unsigned int Elapsed = 0;<br />static char pid_array[MAXPIDNUM + 1];<br />const char * fdir = "./fstack/Finished/";<br /><br /><br />void * <br />Timer_thread (void * unused)<br />{ <br />  struct timespec ttime = {<br /> 0, THREADMAXNANOTIME<br />  };<br />  int oldcancelstate;<br />  while (Elapsed &lt; MaxTime) {<br /> nanosleep (&amp;ttime, NULL);<br /> pthread_setcancelstate (PTHREAD_CANCEL_DISABLE, &amp;oldcancelstate);<br /> Elapsed++;<br /> pthread_setcancelstate (oldcancelstate, NULL);<br />  }<br />}<br /><br />char<br />Proc_setline (int fd, unsigned int stopline)<br />{<br />  char ch = 0;<br />  signed int nbytes;<br />  unsigned int currentline = 1;<br />  while (currentline != stopline) {<br /> nbytes = read (fd, &amp;ch, 1);<br /> if (nbytes == 0)<br />   return EOF;<br /> else if (nbytes == -1)<br />   err (1, "Proc_setline");<br />  <br /> if (ch == '\n')<br />   currentline++;<br />  }<br />}<br /><br />char<br />Proc_readline (int fd)<br />{<br />  int rval;<br />  char line[7];<br />  if (PBuffer.proc.state != 0) <br /> /* The process is waiting for other process */<br /> if (pid_array[PBuffer.proc.state] != 0) <br />   /* that not occored yet */<br />   return 1;<br />  lseek (fd, 0, SEEK_SET);<br />  rval = Proc_setline (fd, PBuffer.proc.stopline);<br />  if (rval == EOF)<br /> return EOF;<br />  read (fd, line, 7);<br />  line[7] = '\0';<br />  printf ("\E[33m\tExecuting line %d (%s) from file %s\n\E[0m", <br />    PBuffer.proc.stopline, line, PBuffer.proc.filename);<br />  if (strcmp (line, "wait") &gt; 0) {<br /> /* wait found */<br /> int pid_to_wait;<br /> sscanf (line, "wait %d", &amp;pid_to_wait);<br /> PBuffer.proc.state = pid_to_wait;<br /> /* This will be 0 again when the process<br />    `pid_to_wait' ends */<br /> pid_array[pid_to_wait] = PBuffer.proc.pid;<br /> PBuffer.proc.stopline++;<br /> return 1;<br />  } <br />  else if (strcmp (line, "fork 00") == 0) {<br /> /* fork found */<br /> PBuffer.proc.stopline++;<br /> return 2;<br />  }<br /> PBuffer.proc.stopline++;<br />  return 0;<br />}<br /> <br />  <br />void *<br />Process_thread (void * unused)<br />{<br />  struct timespec process_time = { 0, 1000 };<br />  pthread_t timer_thread_id;<br />  int fd; <br />  char rval, * old, * new;<br /><br /> START_PROCESS: while (1) { <br /><br /> /* While Queue is empty, Wait */<br /><br /> while (QSize == 0) <br />   nanosleep (&amp;process_time, NULL);<br /><br /> pthread_mutex_lock (&amp;mutex); <br /> printf ("\tPROCESS LOOP START\n");<br /> sleep (1);<br /> /* Read a process from queue */<br /> q_read (&amp;PBuffer);<br /> printf ("\E[35m\tTaked a process from queue pid:%d | filename %s\n\E[0m", <br />   PBuffer.proc.pid, PBuffer.proc.filename);<br /> printf ("\E[34m\t QueueSize = %d\n", QSize);<br /> sleep (1);<br /> /* Start Timer according wiht priority */<br /> MaxTime = PBuffer.proc.priority;<br /> char * filename = create_filepath (rdir, PBuffer.proc.filename);<br /> printf ("\E[33m\topening file %s\n\E[0m", filename);<br /> fd = xopen (filename, O_RDONLY, 0);<br /> free (filename); <br /> printf ("\E[35m\tStarting timer\n\E[0m");<br /> pthread_create (&amp;timer_thread_id, NULL, &amp;Timer_thread, NULL);<br /> /* Until EOF */<br /> while ((rval = Proc_readline(fd)) != EOF) {<br />   if (rval == 1) {<br />  /*<br />   * This process was set to wait for other process <br />   * reshedule it util the wait process ends<br />   */<br />  pthread_cancel (timer_thread_id);<br />  pthread_join (timer_thread_id, NULL);<br />  close (fd);<br />  Elapsed = 0;<br />  printf ("\E[32m\tWaiting for pid:%d\n\E[0m", PBuffer.proc.state);<br />  Sched_writebuf (PBuffer.proc.pid, PBuffer.proc.state, PBuffer.proc.fork,<br />      PBuffer.proc.stopline, Elapsed * 1000, PBuffer.proc.priority, <br />      PBuffer.proc.filename);<br />  printf ("\tPROCESS FINISH\n");<br />  sleep (1);<br />  pthread_mutex_unlock (&amp;mutex);<br />  nanosleep (&amp;process_time, NULL);<br />  goto START_PROCESS;<br />   }<br />   else if (rval == 2) {<br />  /* fork found */<br />  char * wholefname, * fname, pidchar[2], buf[100];<br />  int newfiled, nbytes;<br />  fname = create_filepath ("F", (PBuffer.proc.filename+1));<br />  wholefname = create_filepath (rdir, fname);<br />  /* Copy the file */<br />  printf ("\E[32m\tCopying file %s%s -&gt; %s\n\E[0m", <br />    rdir, PBuffer.proc.filename, wholefname);<br />  newfiled = xopen (wholefname, O_RDWR | O_CREAT, S_IRUSR | S_IWUSR);<br />  lseek (fd, 1, SEEK_CUR);<br />  while ((nbytes = read (fd, buf, 100)) &gt; 0)<br />   write (newfiled, buf, nbytes);<br />  if (nbytes == -1)<br />    errx (1, "read error");<br />  /* End of copy file */<br />  printf ("\E[32m\tFork found making a copy of process. Pid: %d\n\E[0m",<br />    PidCounter + 10);<br />  Sched_writebuf (PidCounter + 10, PBuffer.proc.state, 2, 1, <br />      0, PBuffer.proc.priority, fname);<br />  free (fname);<br />  free (wholefname);<br />  PidCounter++;<br />  PBuffer.proc.fork = 1; /* this is the original one */<br />   }<br />   /* if Time Out, reschedule */<br />   else if (Elapsed == MaxTime) {<br />  pthread_join (timer_thread_id, NULL);<br />  printf ("\E[31m\tTime exceded at priority %d, rescheduling pid:%d %s\n\E[0m", <br />    PBuffer.proc.priority, PBuffer.proc.pid, PBuffer.proc.filename);<br />  Sched_writebuf (PBuffer.proc.pid, PBuffer.proc.state, PBuffer.proc.fork,<br />      PBuffer.proc.stopline, Elapsed * 1000 + PBuffer.proc.spendtime<br />      , PBuffer.proc.priority, PBuffer.proc.filename);<br />  close (fd);<br />  Elapsed = 0;<br />  printf ("\tPROCESS FINISH\n");<br />  sleep (1);<br />  pthread_mutex_unlock (&amp;mutex);<br />  nanosleep (&amp;process_time, NULL);<br />  goto START_PROCESS;<br />   }<br /> }<br /> /* The curret process ends */<br /> close (fd);<br /> printf ("\E[31m\tEOF %s\n\E[0m", PBuffer.proc.filename);<br /> /* if was some other waiting for it .. release */<br /> if (pid_array[PBuffer.proc.pid] != 0) {<br />   printf ("\E[32m\tReleazing process pid:%d\n\E[0m", pid_array[PBuffer.proc.pid]);<br />   pid_array[PBuffer.proc.pid] = 0;<br /> }<br /> printf ("\E[31m\tTime expense %d nanoseconds at prioriry %d\n", <br />   PBuffer.proc.spendtime + (1000 * Elapsed), PBuffer.proc.priority);<br /> pthread_cancel (timer_thread_id);<br /> pthread_join (timer_thread_id, NULL);<br /> Elapsed = 0;<br /> new = create_filepath (fdir, PBuffer.proc.filename);<br /> old = create_filepath (rdir, PBuffer.proc.filename);<br /> sleep (1);<br /> printf ("\E[32m\tmoving %s -&gt; %s\n\E[0m", old, new);<br /> xrename (old, new);<br /> free (old);<br /> free (new);<br /> sleep (1);<br /> printf ("\tPROCESS LOOP FINISH\n");<br /> pthread_mutex_unlock (&amp;mutex);<br /> nanosleep (&amp;process_time, NULL);<br />  } <br />}<br /></pre><br /><pre class="brush:c">/*<br /> * file: filequeue.c<br /> */<br />#include &lt;err.h&gt;<br />#include &lt;stdlib.h&gt;<br />#include &lt;string.h&gt;<br /><br />#include "fakek.h"<br /><br />/* Init Global variables */<br />queue_type * GFirst = NULL;<br />queue_type * GLast = NULL;<br />unsigned int QSize = 0;<br />unsigned int PidCounter = 0;<br /><br />void *<br />q_write (queue_type * buf)<br />{<br />  queue_type * new = (queue_type *) malloc (sizeof (queue_type));<br />  if (new == NULL)<br /> errx (2, "q_write (malloc fail)");<br />  /* Set data */<br />  memcpy (new, buf, sizeof (queue_type));<br />  new-&gt;next = NULL;<br />  /* Set Globals */<br />  if (QSize == 0)<br /> GFirst = GLast = new;<br />  else {<br /> GLast-&gt;next = new;<br /> GLast = new;<br />  }<br />  QSize++;<br />}<br /><br />void *<br />q_read (queue_type * buf)<br />{<br />  if (QSize &lt; 1)<br /> errx (1, "Queue is empty, wrong q_read call");<br />  /* Save data */<br />  memcpy (buf, GFirst, sizeof (queue_type));<br />  /* Set Globals */<br />  queue_type * tmp = GFirst;<br />  GFirst = GFirst-&gt;next;<br />  /* Free the read data */<br />  free (tmp);<br />  /* Set the queue size need be last thing to do<br />  to avoid race conditions */<br />  QSize--;<br />}<br /><br />void *<br />q_destroy (void)<br />{<br />  unsigned int released_items = 0;<br />  queue_type * tmp;<br />  while ((tmp = GFirst) != NULL) {<br /> GFirst = GFirst-&gt;next;<br /> free (tmp);<br /> released_items++;<br />  }<br />  GLast = NULL;<br />  QSize = 0;<br />  return (void *) released_items;<br />}<br /></pre><br /><pre class="brush:c">/*<br /> * file: fakek.h<br /> */<br />#ifndef FAKEK_H<br />#define FAKEK_H<br /><br />#include &lt;dirent.h&gt;<br />#include &lt;err.h&gt;<br />#include &lt;fcntl.h&gt;<br />#include &lt;pthread.h&gt;<br />#include &lt;stdlib.h&gt;<br />#include &lt;stdio.h&gt;<br />#include &lt;string.h&gt;<br />#include &lt;sys/stat.h&gt;<br />#include &lt;sys/types.h&gt;<br />#include &lt;unistd.h&gt;<br /><br /><br />/*<br /> * Defined in filequeue.c<br /> */<br />typedef struct proc_strc {<br />  unsigned int pid;<br />  unsigned int state;<br />  unsigned int fork;<br />  unsigned int stopline;<br />  unsigned int spendtime;<br />  unsigned int priority;<br />  char filename[5];<br />} proc_type;<br /><br />typedef struct queue_strc {<br />  proc_type proc;<br />  struct queue_strc * next;<br />} queue_type;<br /><br />/* Global First and Last processs in Queue */<br />extern queue_type * GFirst;<br />extern queue_type * GLast;<br />/* Queue Size */<br />extern unsigned int QSize;<br /><br />/* pid counter */<br />extern unsigned int PidCounter;<br /><br />/* Fifo like functions */<br />extern void * q_write (queue_type *);<br />extern void * q_read (queue_type *);<br />extern void * q_destroy (void);<br /><br /><br />/*<br /> * Defined in common.c<br /> */<br />extern DIR * xopendir (const char *);<br />extern void * xmalloc (size_t);<br />extern int xopen (const char *, int, mode_t);<br />extern char * create_filepath (const char *, const char *);<br /><br />/* <br /> * Defined in scheduler.c<br /> */<br />extern const char * userdir;<br />extern const char * sysdir;<br />extern const char * rdir;<br />extern queue_type QBuffer;<br />extern void Sched_writebuf (unsigned int, unsigned int, unsigned int,<br />       unsigned int, unsigned int, unsigned int, char *);<br />extern struct dirent * Sched_getrfile (DIR *);<br />extern void * Scheduler_thread (void *);<br /><br />/*<br /> * Defined int process.c <br /> */<br />extern const char * fdir;<br />extern queue_type PBuffer;<br />extern unsigned int MaxTime;<br />extern unsigned int Elapsed;<br />extern void * Timer_thread (void *);<br />extern char Proc_setline (int, unsigned int);<br />extern char Proc_readline (int fd);<br />extern void * Process_thread (void *);<br />#endif <br /><br />/*<br /> * Defined in main <br /> */<br />extern pthread_mutex_t mutex;<br /><br /></pre><br /><pre class="brush:c">/*<br /> * file: main.c<br /> */<br />#include "fakek.h"<br />#include &lt;pthread.h&gt;<br /><br />pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER;<br /><br />int<br />main (void)<br />{<br />  pthread_t Scheduler_id, Process_id;<br />  pthread_create (&amp;Process_id, NULL, &amp;Process_thread, NULL);  <br />  pthread_create (&amp;Scheduler_id, NULL, &amp;Scheduler_thread, NULL);<br />  pthread_join (Scheduler_id, NULL);<br />  pthread_join (Process_id, NULL);<br />  <br />  return 0;<br />}<br /></pre><br /><pre class="brush:shell">fakek: main.c common.o filequeue.o process.o scheduler.o fakek.h<br /> gcc $(CFLAGS) -o fakek main.c common.o filequeue.o process.o scheduler.o fakek.h -lpthread<br /> mkdir -p ./fstack/System ./fstack/User ./fstack/Running ./fstack/Finished<br /><br />common.o: common.c fakek.h<br /> gcc $(CFLAGS) -c common.c<br /><br />filequeue.o: filequeue.c fakek.h<br /> gcc $(CFLAGS) -c filequeue.c<br /><br />process.o: process.c fakek.h<br /> gcc $(CFLAGS) -c process.c<br /><br />scheduler.o: scheduler.c fakek.h<br /> gcc $(CFLAGS) -c scheduler.c<br /><br />clean:<br /> rm -vf common.o fakek filequeue.o process.o scheduler.o <br /></pre>thats it