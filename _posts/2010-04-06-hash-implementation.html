---
layout: post
title: hash implementation
date: '2010-04-06T09:40:00.000-07:00'
author: Daniel Hilst
tags: 
modified_time: '2010-04-06T09:40:34.418-07:00'
blogger_id: tag:blogger.com,1999:blog-8785437776394405849.post-6782729057383368887
blogger_orig_url: http://gkos-hw.blogspot.com/2010/04/hash-implementation.html
---

some hash<br /><br /><pre class="brush: c">#include &lt;stdio.h&gt;<br />#include &lt;stdlib.h&gt;<br />#include &lt;string.h&gt;<br /><br />#define HSH_EMPTY "__EMPTY__"<br />#define HSH_MAX_SIZE 3 <br />#define HSH_FOUND 0<br />#define HSH_FOUND_FIRST 1<br />#define HSH_NOT_FOUND -1<br />#define HSH_NOT_INIT -2<br /><br />typedef struct hash_node {<br /> struct hash_node *n;<br /> char *k;<br /> char *v;<br />} hash_type;<br /><br />extern void     hash_delete  (hash_type **, char *); <br />extern char    *hash_get   (hash_type **, char *);<br />extern void     hash_pairs     (hash_type **, void (*func)(hash_type *));<br />extern void     hash_set   (hash_type **, char *, char *);<br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br />void<br />print_pair (hash_type *p)<br />{<br /> printf ("%s -&gt; %s\n", p-&gt;k, p-&gt;v);<br />}<br /><br />hash_type *me[HSH_MAX_SIZE];<br /><br />int<br />main (void)<br />{ <br /> hash_set (me, "nome", "Daniel");<br /> hash_set (me, "sobrenome", "Hilst");<br /> hash_delete (me, "nome");<br /> printf ("%s %s\n", hash_get (me, "nome"), hash_get (me, "sobrenome"));<br /> return 0;<br />}<br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br />struct hash_found {<br /> signed int s;<br /> hash_type *p;<br />};<br /><br />static hash_type   *hash_alloc  (void);<br />static unsigned    hash_index  (char *);<br />static struct hash_found  hash_lookup (hash_type **, char *, unsigned); <br /><br />void<br />hash_delete (hash_type *h[], char *k)<br />{ <br /> unsigned i = hash_index (k);<br /> struct hash_found f = hash_lookup (h, k, i);<br /> hash_type *p, *prev;<br /> if (f.s == HSH_FOUND) {<br />  prev = f.p;<br />  p = f.p-&gt;n;<br />  prev-&gt;n = prev-&gt;n-&gt;n;<br />  free (p-&gt;k);<br />  free (p-&gt;v);<br />  free (p);<br /> }<br /> else if (f.s == HSH_FOUND_FIRST) {<br />   p = h[i];<br />  h[i] = h[i]-&gt;n;<br />  free (p-&gt;k);<br />  free (p-&gt;v);<br />  free (p);<br /> }  <br />}<br /><br />char *<br />hash_get (hash_type *h[], char *k)<br />{ <br /> unsigned i = hash_index (k);<br /> struct hash_found f = hash_lookup (h, k, i);<br /> if (f.s == HSH_FOUND) {<br />  return f.p-&gt;n-&gt;v;<br /> }<br /> else if (f.s == HSH_FOUND_FIRST) { <br />  return f.p-&gt;v;<br /> }<br /> return HSH_EMPTY;<br />}<br /><br />void<br />hash_pairs (hash_type *h[], void (*func)(hash_type *))<br />{ <br /> unsigned i = 0;<br /> hash_type *p = h[i];<br /> for (; i &lt; HSH_MAX_SIZE;) {<br />  for(; p != NULL; p = p-&gt;n)<br />   func (p);<br />  p = h[++i];<br /> }<br />}<br /><br />void<br />hash_set (hash_type *h[], char *k, char *v)<br />{ <br /> unsigned i = hash_index (k);<br /> struct hash_found f = hash_lookup (h, k, i);<br /> hash_type *p, *prev;<br /> <br /> if (f.s == HSH_FOUND) {<br />  p = f.p-&gt;n;<br />  free (p-&gt;v);<br />  p-&gt;v = strdup (v); <br /> }<br /> else if (f.s == HSH_FOUND_FIRST) {<br />  p = f.p;<br />  free (p-&gt;v);<br />  p-&gt;v = strdup (v);<br /> }<br /> else if (f.s == HSH_NOT_INIT) {<br />  p = h[ i ] = hash_alloc ();<br />  p-&gt;k = strdup (k);<br />  p-&gt;v = strdup (v);<br />  p-&gt;n = NULL;<br /> }<br /> else { // if (f.s == HSH_NOT_FOUND) {<br />  prev = f.p;<br />  p = prev-&gt;n = hash_alloc ();<br />  p-&gt;k = strdup (k);<br />  p-&gt;v = strdup (v); <br /> }<br />}<br /><br /><br /><br /><br /><br /><br /><br /><br /><br />static hash_type *<br />hash_alloc (void)<br />{<br /> hash_type *new = (hash_type *) malloc (sizeof (hash_type));<br /> if (new == NULL) {<br />  fprintf (stderr, "malloc error\n");<br />  exit (EXIT_FAILURE);<br /> }<br /> return new;<br />}<br /><br />static unsigned<br />hash_index (char *k)<br />{ <br /> unsigned i;<br /> for (i = 0; *k != '\0'; k++)<br />  i += *k;  <br /> return i % HSH_MAX_SIZE;<br />}<br /><br />static struct hash_found <br />hash_lookup (hash_type **h, char *k, unsigned i) /* hash, key, index */ <br />{ <br /> hash_type *p, *prev;<br /> p = h[ i ];<br /> if (p == NULL) <br />  return (struct hash_found) {HSH_NOT_INIT, NULL};<br /> else if (strcmp (p-&gt;k, k) == 0)<br />  return (struct hash_found) {HSH_FOUND_FIRST, p};<br /><br /> prev = p;<br /> p = p-&gt;n;<br /> for (; p != NULL; p = p-&gt;n) {<br />  if (strcmp (p-&gt;k, k) == 0)<br />   return (struct hash_found) {HSH_FOUND, prev};<br />  prev = p;<br /> } <br /> return (struct hash_found) {HSH_NOT_FOUND, prev};<br />}<br /></pre><br />use:<br />   hash_type *MONHASH[HSH_MAX_SIZE]; // the HSH_MAX_SIZE is mandatory here, if this ins't global<br />you need to initializate every element of it to NULL;<br /><br />   hash_set (MONHASH, "KEY", "VALUE"); // install a key or change it<br />   hash_get (MONHASH, "KEY"); // returns "VALUE" or "__EMPTY__" if doesn't found it<br />   hash_delete (MONHASH, "KEY"); // delete the pair "KEY" "VALUE" and free its memory<br />   hash_pairs (MONHASH, FUNC); for each pair in hash execute the function FUNC passing the pair to it via MONHASH, entry; (e.g) <i>void f (hash_type *h) { puts (h->k) };</i>. Then <i> hash_pairs (MONHASH, f);</i><br /><br /><br /><br />What else... math makes me fell sad..