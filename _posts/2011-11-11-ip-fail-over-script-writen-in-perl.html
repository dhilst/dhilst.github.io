---
layout: post
title: IP Fail over script writen in perl
date: '2011-11-11T12:53:00.001-08:00'
author: Daniel Hilst
tags:
- ping
- perl
- ip failover
modified_time: '2011-11-14T11:38:57.043-08:00'
blogger_id: tag:blogger.com,1999:blog-8785437776394405849.post-4321828998935678823
blogger_orig_url: http://gkos-hw.blogspot.com/2011/11/ip-fail-over-script-writen-in-perl.html
---

This perl script provides an IP Fail Over enviroment, by testing the routes an jumping from one to another if the current route falls out of service. <br />More information on script comments.<br /><br /><br /> <pre class='brush: perl'><br />#!/usr/bin/perl  <br />#<br /># (c) Daniel Hilst Selli, 2011, &lt;danielhilst@gmail.com&gt;<br />#<br /># IP FAIL OVER <br />#<br /># Desc: Provides a IP FAIL OVER environment by testing the current routing and<br />#       changing it to next route if it fails. "ip" utility is used to change<br />#       the routes. <br />#<br /># Usage: You need to configure the routes at @routes array. <br /># /\_______update_the_comment_______________________/\<br />#<br />#       When ping fails on current route, the script searches for a new valid<br />#       route. That valid route will be the new default route.<br />#<br />#       The entry 0 is the standard route. You can request the script to go back<br />#       to standar route by sending a SIGUSR to it. The standard route will be<br />#       checked, if is not yet valid the script will not change the current<br />#       route.<br />#<br />#       $dest_host is the url that you will ping. I have setted it to<br />#       "www.google.com" but you can change it if needed.<br />#<br />#       This script goes to background as soon as possible. As a service should<br />#       do. You can define the log of it on $daemon_log variable. Its default is<br />#       the name of the script followed by ".log".<br />#<br /><br /><br />use strict;<br />use warnings; <br />use Net::Ping; <br />use POSIX qw(setsid);<br />use Time::localtime;<br />use Fcntl qw(:flock SEEK_END);<br /><br /><br />#<br /># START CONFIGURE HERE<br />#<br />my @routes = (<br />        {<br />#                iface =&gt;  "ppp0",<br />                source =&gt; "200.171.87.72",<br />                gateway =&gt; "dev ppp0",<br />  init =&gt;  sub {<br />      print ctime() .  " Rebooting ppp0\n";<br />      `ifdown ppp0`;<br />      `ifup ppp0`;<br />  },<br />        },<br />        {<br />                iface =&gt; "eth2",<br />                source =&gt; undef,<br />                gateway =&gt; "via 192.168.5.1",<br />        },<br />);<br />my $dest_host = "www.google.com";<br />my $standard_route = 1; # Used as index to @routes. So $routes[0] is the <br />                        # standard route   <br />my $daemon_log = $0 . ".log"; <br />#<br /># STOP CONFIGURE HERE<br />#<br /><br /><br /><br />#<br /># Initialization <br /># <br />my $continue = 1;<br />my $pid;<br />my $indx = undef; <br />my $current_route = undef;<br />my $pid_file = "$0.pid";<br />my $pid_fh = undef;<br />my $file_lock_fh = undef;<br />my $file_lock_fname = "$0.lck";<br />$| = 1; # unbuffered STDOUT<br /><br />$SIG{TERM} = sub { $continue = 0 };<br /><br />$SIG{USR1} = sub {<br />        print ctime() . " Standard route requested\n";<br />        if ($routes[$standard_route] == $current_route) {<br />                print ctime() . " the standard route is already".<br />                " being used, nothing to do\n";<br />        } elsif ($routes[$standard_route]-&gt;{ping}-&gt;ping($dest_host)) {<br />                print ctime() .  " Standard route is valid, ".<br />                "backing to it\n";<br />                $indx = $standard_route;<br />                set_route();<br />        } else {<br />                print ctime() . " Standard route offline, nothing to do\n";<br />        }<br />};<br /><br />sub init_routes {<br />        for my $r (@routes) {<br />                if ($r-&gt;{source}) {<br />                        $r-&gt;{ping} = Net::Ping-&gt;new("icmp", 1);<br />                        $r-&gt;{ping}-&gt;bind($r-&gt;{source});<br />  } elsif ($r-&gt;{iface}) {<br />      $r-&gt;{ping} = Net::Ping-&gt;new("icmp", 1, 64, $r-&gt;{iface}); <br />  } else {<br />      die "Route without source and iface member\n".<br />   "You need at least one of them\n";<br />  }<br />        } <br /><br />        die "\$standard_out setted to out of bounds of ". <br />        "\@routes array\n" if $standard_route &gt; $#routes;<br /><br />        $indx = $standard_route;<br />        set_route();<br />}<br /><br />sub do_flock {<br />        open($file_lock_fh, "&gt;$file_lock_fname") or die "Can't open lock file".<br /> " $file_lock_fname";<br />        unless(flock($file_lock_fh, LOCK_EX | LOCK_NB)) {<br />                die "Cannot obtain lock. If there is another instance of".<br />                "this running kill it and try again";    <br />        }<br />}<br /><br />sub do_funlock {<br />        my ($fname) = @_; <br />        unless(flock($file_lock_fh, LOCK_UN)) {<br />                die "Cannot release lock, this shouldn't be happening";<br />        }<br />        close($file_lock_fh);<br />}<br /><br />sub set_route {<br />        $current_route =  $routes[$indx];<br />        print ctime() . " Changing route to ".<br />        "$current_route-&gt;{gateway}\n";<br /> <br /> $current_route-&gt;{init}() if $current_route-&gt;{init};<br /><br />        my $error = `ip route del default`; <br />        print " Can't delete default route\n" if $error;<br /><br />        $error = `ip route add default $current_route-&gt;{gateway}`;<br />        die " Can't add default route" if $error;<br /><br /> print ctime() . " Route changed\n";<br />}<br /><br /># Args<br /># 1 =&gt; Ref to global $indx variable<br /># 2 =&gt; The limmit <br />sub next_indx {<br />        my ($indx, $limit) = @_;<br />        $$indx++;<br />        if ($$indx &gt; $limit) {<br />                $$indx = 0;<br />        }<br />}<br /><br /><br />sub on_fail {<br />        my $error;<br />        <br />        print ctime() . " Ping failed\n";<br />        print ctime() . " Default route is $current_route-&gt;{gateway}. Adding new route\n";<br />        $error = `ip route del default via $current_route-&gt;{gateway}`; <br />        die $! if $error;<br /><br />        next_indx(\$indx, $#routes);<br />        set_route();<br /><br />        print ctime() . " New route $current_route-&gt;{gateway} added\n";<br />}<br /><br /><br />sub daemonise {<br />        umask 0;<br />        open STDIN, '/dev/null'   or die "Can't read /dev/null: $!";<br />        open STDOUT, "&gt;$daemon_log" or die "Can't write to log: $!";<br />        open STDERR, "&gt;$daemon_log" or die "Can't write to log: $!";<br />        defined(my $pid = fork)   or die "Can't fork: $!";<br />        exit if $pid;<br />        setsid                    or die "Can't start a new session: $!"; }<br /><br />#<br /># MAIN LOOP<br />#<br /><br /><br />do_flock();<br />daemonise();<br />init_routes();<br />while ($continue) {<br />        if ($current_route-&gt;{ping}-&gt;ping($dest_host)) {<br />#               print ctime();<br />#   if ($current_route-&gt;{source}) {<br />#       print " $current_route-&gt;{source} live\n";<br />#   } else {<br />#       print " $current_route-&gt;{iface} live\n";<br />#   }<br />                sleep(3);<br />        } else {<br />                on_fail();<br />        }<br />}<br />do_funlock();<br /><br /><br /># vim:ft=perl:tabstop=8:shiftwidth=4:smarttab:noexpandtab:softtabstop=4:ai:tw=80<br /><br /><br /></pre>