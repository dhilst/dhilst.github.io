---
layout: post
title: gkos Linked List API
date: '2010-10-13T14:23:00.000-07:00'
author: Daniel Hilst
tags: 
modified_time: '2010-10-22T19:47:28.512-07:00'
blogger_id: tag:blogger.com,1999:blog-8785437776394405849.post-9213485191990039242
blogger_orig_url: http://gkos-hw.blogspot.com/2010/10/gkos-linked-list-api.html
---

The linked list api that I talked about some weeks ago.<br /><br />I will try to keep it simple, but this was not optimized.<br /><br /><br />There are 2 files: <i>llapi.h, libllapi.c.</i><br /><br />The first you will include in your application as:<br /><pre class="brush:c ">#include "llapi.h"</pre>The secont you will use to make an archive.<br />Do as follow:<br /><pre class="brush:bash ">gcc -c libllapi.c<br />ar -rcs libllapi.a libllapi.o<br /></pre><br /><br />Before to use your list you need to declare and <br />initialize it.<br /><pre class="brush:c ">llist mylist;<br />init_llist (&amp;mylist);<br /></pre><br />Ok, now you have a ready to use list, but, what you<br />may put inside it? The answer is nodes, of course.<br />Nodes are declared as an struct containing three members:<br /><ul><li>a key for you search it latter</li><li> a data field with <i>BUFSIZ </i>bytes</li><li>a pointer to next node</li></ul>So you need a node buffer, and maybe a data buffer<br /><pre class="brush:c ">node *nodebuf;<br />char data[BUFSIZ];<br /></pre><span style="color: red; font-size: xx-small;"><br />note: The data buffer need to have <i>BUFSIZ</i> length because the <i>init_node()</i> will try to copy <i>BUFSIZ</i> bytes to node data member. If data buffer has less than <i>BUFSIZ</i> bytes you will recieve a segment fault error at run time, since <i>init_node() </i>will try to dereference an array beyond its boundaries.<br /></span><br />You can initialize a node as<br /><pre class="brush:c ">nodebuf = init_node ("KeyName", data);<br /></pre>Or you can initialize it by hand. Then, with an initialized<br />node you can add it in list with:<br /><pre class="brush:c ">add_node (&amp;mylist, nodebuf);<br /></pre>After that your node is added in your list. The bufnode will<br />be set to null, so you can't touch list through it. The maximum number<br />of nodes is demilited by your avaible memory. The nodes are allocated<br />inside init_node function. If there is no memory avaible the programm<br />will exit with a failure status and an error message.<br /><br />&nbsp;Since this you may want to free some space, to do this you will need<br />to delete some nodes. You can delete a node with <i>del_node ()</i> function<br />but you need to know what to delete before to delete. The <i>search_node ()</i><br />function is what you want.<br /><pre class="brush:c ">struct search_result sr = search_node (&amp;mylist, "keyname");</pre>search_result struct is declared as follow:<br /><pre class="brush:c ">struct search_result {<br />    node *n; <br />    node *prior;<br />};<br /></pre><i>n</i> points to node that you searched. It will be <i>NULL</i> if your node was not found.<br /><i>prior</i> is an implementation detail. If the node was found and it's not the first<br />item in list, <i>prior</i> will point the prior node of <i>n</i>.<br /><br /><br />Now that you found (or not) your node, <i>sr.n</i> points to it. You can delete it<br />with the follow statement:<br /><pre class="brush:c ">int rval = del_node (&amp;mylist, sr.n, sr.prior);&nbsp;</pre>The integer <i>rval </i>will hold the return status of <i>del_node ()</i> function.<br />Note that I don't check if my <i>"keyname"</i> was found. The <i>del_node ()</i> function<br />will return <i>BAD_CALL</i> if you call it with 2nd and 3rd arguments as <i>NULL</i><br />and will stat if you are trying to delete the first node. The <i>sr.prior</i> member<br />is used to linking stuff, but you don't need to botter with it, just recieve<br />from <i>search_node ()</i> and pass as it is to <i>del_node ()</i> everything is stated<br />by <i>del_node ()</i>.<br /><br /><br />Here is the two files and an example!<br /><br /><pre class="brush:c ">/*<br />    Copyright 2010 Daniel Hilst Selli    <br />    <br />    This file is part of gkos Linked List API.<br /><br />    gkos Linked List API is free software: you can redistribute it and/or modify<br />    it under the terms of the GNU Lesser Public License as published by<br />    the Free Software Foundation, either version 3 of the License, or<br />    (at your option) any later version.<br /><br />    gkos Linked List API is distributed in the hope that it will be useful,<br />    but WITHOUT ANY WARRANTY; without even the implied warranty of<br />    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the<br />    GNU Lesser Public License for more details.<br /><br />    You should have received a copy of the GNU Lesser Public License<br />    along with gkos Linked List API.  If not, see &lt;http://www.gnu.org/licenses/&gt;.<br /><br />    Daniel Hilst aka gkos &lt;danielhilst@gmail.com&gt;    <br />*/<br /><br />/****************** <br /> *    llapi.h     *<br /> ******************/<br />#ifndef LLAPI_H<br />#define LLAPI_H<br /><br />#include &lt;stdio.h&gt;<br />#include &lt;stdlib.h&gt;<br />#include &lt;string.h&gt;<br /><br />#define KEY_SIZ 8<br />#define EMPTY 0<br />#define HAS_ONE 1<br />#define HAS_MORE_THAN_ONE 2<br />#define ERROR -1<br />#define BADCALL (ERROR -1)<br />#define KEY_FOUND_AT_FIRST (struct search_result) {l-&gt;first, NULL} <br />#define KEY_FOUND            (struct search_result) {np, prior} <br />#define KEY_NOT_FOUND            (struct search_result) {NULL, NULL} <br /><br />/* data */<br />typedef struct node {<br />    struct node *next; <br />    char key[KEY_SIZ + 1]; /* +1 to the nil terminator char */<br />    char *data[BUFSIZ];<br />} node;<br /><br />typedef struct llist {<br />    node *first; /* first item in list */<br />    node *last;  /* last item in list */<br />} llist;<br /><br />struct search_result {<br />    node *n;<br />    node *prior;<br />};<br /><br /><br />/* prototypes */<br />void                     add_node     (llist *, node *);<br />int                     del_node     (llist *, node *, node *);<br />node                     *init_node     (char *k, char *);<br />void                     init_llist     (llist *);<br />struct search_result     search_node    (llist *, char *);<br /><br />#endif // LLAPI_H<br /><br /></pre><br /><br /><pre class="brush:c ">/*<br />    Copyright 2010 Daniel Hilst Selli    <br />    <br />    This file is part of gkos Linked List API.<br /><br />    gkos Linked List API is free software: you can redistribute it and/or modify<br />    it under the terms of the GNU Lesser Public License as published by<br />    the Free Software Foundation, either version 3 of the License, or<br />    (at your option) any later version.<br /><br />    gkos Linked List API is distributed in the hope that it will be useful,<br />    but WITHOUT ANY WARRANTY; without even the implied warranty of<br />    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the<br />    GNU Lesser Public License for more details.<br /><br />    You should have received a copy of the GNU Lesser Public License<br />    along with gkos Linked List API.  If not, see &lt;http://www.gnu.org/licenses/&gt;.<br /><br />    Daniel Hilst aka gkos &lt;danielhilst@gmail.com&gt;    <br />*/<br />/********************** <br /> *     libllapi.c     * <br /> **********************/<br />#include "llapi.h"<br />#define PRIVATE static<br /><br />/* internal prototypes */<br />PRIVATE node *alloc_node (void);<br />PRIVATE int isempty (llist *);<br /><br /><br />/* interface */<br /><br />void<br />add_node (llist *l, node *n)<br />{<br />    int rval = isempty (l);<br />    if (rval == EMPTY) {<br />        l-&gt;first = l-&gt;last = n;<br />    } else if (rval == HAS_ONE) {<br />        l-&gt;first-&gt;next = n;<br />        l-&gt;last = n;    <br />    } else if (rval == HAS_MORE_THAN_ONE) {<br />        l-&gt;last-&gt;next = n;<br />        l-&gt;last = n;<br />    } else {<br />        perror ("isempty");<br />        exit (EXIT_FAILURE);<br />    }<br />    n = NULL; /* so peopple can't touch list directly */<br />}<br /><br />int<br />del_node (llist *l, node *n, node *prior)<br />{<br />    int rval = isempty (l);<br />    if (rval == HAS_ONE) {<br />        init_llist (l); /* set list as empty again */<br />        free (n);<br />    } else if (rval == HAS_MORE_THAN_ONE) {<br />        if (n == l-&gt;first) {<br />            l-&gt;first = l-&gt;first-&gt;next;<br />            free (n); /* or free (l-&gt;first) */        <br />        } else if (n == l-&gt;last) {<br />            l-&gt;last = prior;<br />            l-&gt;last-&gt;next = NULL;<br />            free (n); /* or free the ex last */<br />        } else {<br />            prior-&gt;next = prior-&gt;next-&gt;next; /* link over n */<br />            free (n);<br />        }<br />    } else if (rval == EMPTY) { /* the list is empty */ <br />        return BADCALL;<br />    } else {<br />        return ERROR;<br />    }<br />    return 0;<br />}<br /><br />void<br />init_llist (llist *l)<br />{<br />    l-&gt;first = l-&gt;last = NULL;    <br />}<br /><br />node * <br />init_node (char *k, char *data)<br />{<br />    /* alloc new node */<br />    node *new = alloc_node ();<br />    /* set next */<br />    new-&gt;next = NULL;<br />    /* set key */<br />    strncpy (new-&gt;key, k, KEY_SIZ); <br />    new-&gt;key[KEY_SIZ] = '\0';<br />    /* set data */<br />    memcpy (new-&gt;data, data, BUFSIZ);<br />    /* return the new initalized node */<br />    return new;<br />}<br /><br /><br />struct search_result<br />search_node (llist *l, char *k)<br />{<br />    struct node *np, *prior;<br />    if (strlen (k) &gt; KEY_SIZ) {<br />        k[KEY_SIZ] = '\0';<br />    }<br />    if (strcmp (l-&gt;first-&gt;key, k) == 0) {<br />        return (struct search_result) KEY_FOUND_AT_FIRST; /* (struct search_result) {l-&gt;first, NULL} */<br />    } else {<br />        for (np = l-&gt;first-&gt;next, prior = l-&gt;first; np != NULL; np = np-&gt;next) {<br />            if (strcmp (np-&gt;key, k) == 0) {<br />                return KEY_FOUND; /* (struct search_result) {np, prior} */ <br />            }<br />            prior = prior-&gt;next;<br />        }<br />        return KEY_NOT_FOUND; /* (struct search_result) {NULL, NULL} */<br />    }<br />    <br />}<br /><br /><br />/* internals */ <br /><br />PRIVATE int <br />isempty (llist *l)<br />{<br />    if (l-&gt;first == NULL &amp;&amp; l-&gt;last == NULL)<br />        return EMPTY;<br />    else if (l-&gt;first == l-&gt;last)<br />        return HAS_ONE;<br />    else if (l-&gt;first-&gt;next != NULL)<br />        return HAS_MORE_THAN_ONE; <br />    else <br />        return ERROR;<br />}<br /><br />PRIVATE node *<br />alloc_node (void)<br />{<br />    node *new = malloc (sizeof (node));<br />    if (new == NULL) {<br />        perror ("malloc");<br />        exit (EXIT_FAILURE);<br />    }<br />    return new;<br />}<br /><br /></pre><br /><br /><pre class="brush:c ">#include &lt;stdio.h&gt;<br />#include "llapi.h"<br /><br />int<br />main (void)<br />{<br />    int i;<br />    llist mylist;<br />    node *bufnode;<br />    char databuffer[BUFSIZ];<br />    memcpy (databuffer, "Daniel Hilst", strlen ("Daniel Hilst") + 1);<br />    struct search_result sr;<br />    init_llist (&amp;mylist);<br /><br />    bufnode = init_node ("name", databuffer);    <br />    add_node (&amp;mylist, bufnode);<br /><br />    bufnode = init_node ("myname", databuffer);    <br />    add_node (&amp;mylist, bufnode);<br /><br />    bufnode = init_node ("thename", databuffer);    <br />    add_node (&amp;mylist, bufnode);<br />    <br />    bufnode = init_node ("onwname", databuffer);    <br />    add_node (&amp;mylist, bufnode);<br /><br />    sr = search_node (&amp;mylist, "thename");<br />    printf ("%s =&gt; %s\n", sr.n-&gt;key, sr.n-&gt;data);<br />    del_node (&amp;mylist, sr.n, sr.prior);<br /><br />    sr = search_node (&amp;mylist, "myname");<br />    printf ("%s =&gt; %s\n", sr.n-&gt;key, sr.n-&gt;data);<br />    del_node (&amp;mylist, sr.n, sr.prior);<br /><br />    sr = search_node (&amp;mylist, "onwname");<br />    printf ("%s =&gt; %s\n", sr.n-&gt;key, sr.n-&gt;data);<br />    del_node (&amp;mylist, sr.n, sr.prior);<br /><br />    sr = search_node (&amp;mylist, "name");    <br />    printf ("%s =&gt; %s\n", sr.n-&gt;key, sr.n-&gt;data);<br />    del_node (&amp;mylist, sr.n, sr.prior);<br />    return 0;<br />}<br /><br /></pre><br />This would print:<br />thename =&gt; Daniel Hilst<br />myname =&gt; Daniel Hilst<br />onwname =&gt; Daniel Hilst<br />name =&gt; Daniel Hilst<br /><br /><i><br /></i><br /><i>*edit</i><br /><i>I create a git repository to this. It's easier to update stuff with git...&nbsp;</i><br /><i>there you'll find an updated README.</i><br /><i><a href="http://github.com/gkos/gko-s-Linked-List">http://github.com/gkos/gko-s-Linked-List</a></i><br /><i><br /></i><br /><br />cheers! :-)