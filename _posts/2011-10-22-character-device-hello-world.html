---
layout: post
title: Character device Hello World
date: '2011-10-22T13:09:00.000-07:00'
author: Daniel Hilst
blogger: true
tags:
- char device
- linux
- c
- kernel
modified_time: '2011-11-11T14:35:37.008-08:00'
thumbnail: http://4.bp.blogspot.com/-KnsTpnpmMsE/TqMiAUXlS2I/AAAAAAAAAKw/UDuavUIsCWc/s72-c/2011-10-22-180149_1002x255_scrot.png
blogger_id: tag:blogger.com,1999:blog-8785437776394405849.post-5070719851072984765
blogger_orig_url: http://gkos-hw.blogspot.com/2011/10/character-device-hello-world.html
---

This is a little character device hello World, more<br />information on code.<br /><br /><pre class="brush: c">/*<br /> * file: gkos_char_device.c<br /> *<br /> * Desc: A simple device that<br /> *      echos a message when read,<br /> *      write method not implemented<br /> *<br /> *      This was made on top of <br /> *      LDD and LKMPG examples <br /> *      <br /> */<br /><br />#include &lt;linux/kernel.h&gt;<br />#include &lt;linux/module.h&gt;<br />#include &lt;linux/fs.h&gt;<br />#include &lt;linux/cdev.h&gt;<br />#include &lt;asm/uaccess.h&gt;<br /><br />#define DEVICE_NAME "gkos_char_device"<br /><br /><br />/*<br /> * Prototypes <br /> */<br />int init_module(void);<br />void cleanup_module(void);<br />static int dev_open(struct inode *inode, struct file *);<br />static int dev_release(struct inode *inode, struct file *);<br />static ssize_t dev_read(struct file *fp, char *buf, size_t len, loff_t *off);<br />static ssize_t dev_write(struct file *, const char *buf, size_t len, <br />                loff_t *off);<br />static int dev_init(void);<br /><br />/*<br /> * Our variables, @use_counter<br /> * will block concurrenty opens.<br /> * @buffer is the message and<br /> * @buffer_len the lenght of @buffer (duh)<br /> */<br />static char use_counter = 0;<br />static char buffer[] = "Hello character device world\n";<br />static int buffer_len = sizeof(buffer);<br /><br />static dev_t dev;<br />static struct cdev *cdevp;<br /><br /><br />static struct file_operations fops = {<br />        .owner = THIS_MODULE,<br />        .read = dev_read,<br />        .write = dev_write,<br />        .open = dev_open,<br />        .release = dev_release<br />};<br /><br />/*<br /> * Any device specific initialization<br /> * goes here. Its called at bottom of init_module()<br /> */<br />static int dev_init(void)<br />{<br />        return 0;<br />}<br /><br />/*<br /> * Called when device is opened<br /> */<br />static int dev_open(struct inode *inode, struct file *fp)<br />{<br />        if (use_counter)<br />                return -EBUSY;<br />        use_counter++;<br />        try_module_get(THIS_MODULE);<br />        return 0;<br />}<br /><br />/* <br /> * Called when device is released. The device is<br /> * released when there is no process using it.<br /> */<br />static int dev_release(struct inode *inode, struct file *fp)<br />{<br />        use_counter--;<br />        module_put(THIS_MODULE);<br />        return 0;<br />}<br /><br /><br />/*<br /> * @off controls<br /> * the "walk" through our buffer, is whith @off<br /> * that we say to user where is stoped.<br /> * @len is how much bytes to read. I almost ignore it.<br /> * I just check if is greater than 0.<br /> *<br /> * Called when device is read. <br /> * This method will read one, and only one byte per call,<br /> * If @off is longer than my buffer size or len is not<br /> * greater than 0 it returns 0, otherwise I copy one byte<br /> * to user buffer and returns the bytes readed, so 1.<br /> */<br />static ssize_t dev_read(struct file *fp, char *buf, size_t len, loff_t *off)<br />{<br />        if (*off &gt;= buffer_len || len &lt;= 0)<br />                return 0;<br /><br />        if (copy_to_user(buf, &amp;buffer[*off], 1u))<br />                        return -EFAULT;<br /><br />        (*off)++;<br />        return 1;<br />}<br /><br /><br />/*<br /> * Not implemented at all<br /> */<br />static ssize_t dev_write(struct file *fp, const char *buf, size_t len, <br />                loff_t *off)<br />{<br />        return -ENOSYS;<br />}<br /><br />/*<br /> * Called when module is load<br /> */<br />int init_module(void)<br />{<br />        int error;<br /><br />        /* Alloc a device region */<br />        error = alloc_chrdev_region(&amp;dev, 1, 1, DEVICE_NAME);<br />        if (error) <br />                goto error_out;<br /><br />        /* Registring */<br />        cdevp = cdev_alloc();<br />        if (!cdevp) <br />                return -ENOMEM; <br /><br />        /* Init it! */<br />        cdev_init(cdevp, &amp;fops); <br /><br />        /* Tell the kernel "hey, I'm exist" */<br />        error = cdev_add(cdevp, dev, 1);<br />        if (error &lt; 0) <br />                goto error_out;<br /><br />        printk(KERN_INFO DEVICE_NAME " registred with major %d\n", MAJOR(dev));<br />        printk(KERN_INFO DEVICE_NAME " do: `mknod /dev/%s c %d %d' to create "<br />                        "the device file\n", <br />                        DEVICE_NAME, MAJOR(dev), MINOR(dev)); <br /><br />        /* Device initialization isn't needed yet */<br />        if (dev_init())<br />                goto error_out;<br /><br />        return 0;<br /><br />error_out:<br />        return -EFAULT;<br />}<br /><br />void cleanup_module(void)<br />{<br />        cdev_del(cdevp);<br />}<br /><br />MODULE_LICENSE("GPL");<br /><br /></pre>Makefile: <br /><pre class="brush: bash">obj-m += gkos_char_device.o<br /><br />all:<br /> make -C /lib/modules/$(shell uname -r)/build M=$(PWD) modules <br /> <br />clean:<br /> rm *.ko *.o *.mod.c *.mod.o<br /><br /></pre>Building and Running: <br /><div class="separator" style="clear: both; text-align: center;"><a href="http://4.bp.blogspot.com/-KnsTpnpmMsE/TqMiAUXlS2I/AAAAAAAAAKw/UDuavUIsCWc/s1600/2011-10-22-180149_1002x255_scrot.png" imageanchor="1"><img border="0" height="161" src="http://4.bp.blogspot.com/-KnsTpnpmMsE/TqMiAUXlS2I/AAAAAAAAAKw/UDuavUIsCWc/s640/2011-10-22-180149_1002x255_scrot.png" width="640" /></a></div>