---
layout: post
title: Ping/ICMP example
date: '2011-12-07T16:45:00.001-08:00'
author: Daniel Hilst
blogger: true
tags:
- raw socket
- ICMP ECHO
- ICMP example
- ICMP
- Ping example
- sockets
- raw sockets
- ping example in C
modified_time: '2012-01-05T17:26:54.384-08:00'
blogger_id: tag:blogger.com,1999:blog-8785437776394405849.post-8893262483155182050
blogger_orig_url: http://gkos-hw.blogspot.com/2011/12/pingicmp-example.html
---

I have tried this on my archlinux i686 and works, on arch x86_64 segfaults and I don't no why, I need to work more on this. <pre class="brush: c">/*<br /> * ping.c<br /> *<br /> * An ping example. I have used some iputils code<br /> * you can get the iputils source here: http://www.skbuff.net/iputils/<br /> *<br /> */<br /><br />#include &lt;errno.h&gt;<br />#include &lt;stdio.h&gt;<br />#include &lt;stdlib.h&gt;<br />#include &lt;string.h&gt;<br />#include &lt;sys/socket.h&gt;<br />#include &lt;sys/types.h&gt;<br />#include &lt;netinet/in.h&gt;<br />#include &lt;netinet/ip.h&gt;<br />#include &lt;netdb.h&gt;<br />#include &lt;netinet/ip_icmp.h&gt;<br /><br /><br />#define pexit(s) ({perror(s); exit(EXIT_FAILURE);})<br /><br />u_short in_cksum(const u_short *addr, register int len, u_short csum);<br />void print_icmphdr(struct icmphdr *);<br />void print_iphdr(struct iphdr *);<br /><br />int main(int argc, char **argv)<br />{<br />        int sock;<br />        int len;<br />        int bytes;<br />        int count = -1;<br />        u_short cksum;<br />        u_int16_t seq; <br /><br />        struct sockaddr_in dst_addr;<br />        struct sockaddr_in rcv_addr;<br />        struct hostent *dst_host;<br /><br />#define BUFLEN 1000000<br />        char outpack[BUFLEN];<br />        struct icmphdr *icp; <br />        struct iphdr *ip;<br /><br />        if (argc &lt;= 1) {<br />                printf("Usage: %s HOST [COUNT]");<br />                exit(EXIT_FAILURE);<br />        }<br /><br /><br /><br />        sock = socket(AF_INET, SOCK_RAW, IPPROTO_ICMP);<br />        if (sock == -1)<br />                pexit("socket");<br />        <br />        dst_host = gethostbyname(argv[1]);<br />        if (!dst_host) {<br />                errno = h_errno;<br />                pexit("gethostbyname");<br />        }<br /><br />        memcpy(&amp;dst_addr.sin_addr.s_addr, dst_host-&gt;h_addr_list[0], <br />                        sizeof(dst_addr));<br />        dst_addr.sin_family = PF_INET;<br />        dst_addr.sin_port = 0;<br /><br />        if (argc &gt; 2 )<br />                count = atoi(argv[2]);<br /><br />        seq = 1;<br />        while (count--) {<br />                icp = (struct icmphdr *)outpack;<br />                icp-&gt;type = ICMP_ECHO;<br />                icp-&gt;code = 0;<br />                icp-&gt;un.echo.sequence = seq;<br />                icp-&gt;un.echo.id = getpid(); <br />                icp-&gt;checksum = 0;<br />                icp-&gt;checksum = in_cksum((u_short *)icp, <br />                                sizeof(struct icmphdr), 0);<br /><br />                bytes = sendto(sock, outpack, sizeof(struct icmphdr),<br />                                MSG_DONTWAIT, (struct sockaddr *)&amp;dst_addr,<br />                                sizeof(dst_addr));<br />                if (bytes &lt; 0)<br />                        pexit("sendto");<br /><br />                sleep(1);<br /><br />                len = sizeof(struct sockaddr_in);<br />                bytes = recvfrom(sock, outpack, sizeof(struct iphdr) +<br />                                sizeof(struct icmphdr), MSG_DONTWAIT,<br />                                (struct sockaddr *)&amp;rcv_addr, &amp;len);<br />                if (bytes &lt; 0) /* I'm ignoring incoming errors */<br />                        continue;<br /><br />                ip = (struct iphdr *)outpack;<br />                icp = (struct icmphdr *)&amp;outpack[sizeof(struct iphdr)];<br /><br />                cksum = icp-&gt;checksum;<br />                icp-&gt;checksum = 0;<br />                icp-&gt;checksum = in_cksum((u_short *)icp, <br />                                sizeof(struct icmphdr), 0);<br /><br />                if (cksum != icp-&gt;checksum) /* and ignoring  */<br />                        continue;           /* corrupted packets */<br /><br />                switch(icp-&gt;type) {<br />                case ICMP_ECHOREPLY: /* and repeateds */<br />                        if (icp-&gt;un.echo.sequence &lt; seq)<br />                                continue;<br />                        print_iphdr(ip);<br />                        print_icmphdr(icp);<br />                        putchar('\n');<br />                        seq++;<br />                        break;<br />                case ICMP_DEST_UNREACH:<br />                        printf("Destination unreachable\n");<br />                        break;<br />                }<br /><br />        } <br /><br />        return 0;<br />}<br /><br /><br />/*<br /> * Taken from iputils/ping.c, at http://www.skbuff.net/iputils/<br /> */<br />u_short in_cksum(const u_short *addr, register int len, u_short csum)<br />{<br /> register int nleft = len;<br /> const u_short *w = addr;<br /> register u_short answer;<br /> register int sum = csum;<br /><br /> /*<br />  *  Our algorithm is simple, using a 32 bit accumulator (sum),<br />  *  we add sequential 16 bit words to it, and at the end, fold<br />  *  back all the carry bits from the top 16 bits into the lower<br />  *  16 bits.<br />  */<br /> while (nleft &gt; 1)  {<br />  sum += *w++;<br />  nleft -= 2;<br /> }<br /><br /> /* mop up an odd byte, if necessary */<br /> if (nleft == 1)<br />  sum += htons(*(u_char *)w &lt;&lt; 8);<br /><br /> /*<br />  * add back carry outs from top 16 bits to low 16 bits<br />  */<br /> sum = (sum &gt;&gt; 16) + (sum &amp; 0xffff); /* add hi 16 to low 16 */<br /> sum += (sum &gt;&gt; 16);   /* add carry */<br /> answer = ~sum;    /* truncate to 16 bits */<br /> return (answer);<br />}<br /><br />void print_iphdr(struct iphdr *ip)<br />{<br />        printf("IP tos=%u id=%u ttl=%u saddr=%s daddr=%s ",<br />                       ip-&gt;tos, ip-&gt;id, ip-&gt;ttl, inet_ntoa(ip-&gt;saddr),<br />                       inet_ntoa(ip-&gt;daddr));<br />}<br />void print_icmphdr(struct icmphdr *icp)<br />{<br />        printf("ICMP seq=%d ", icp-&gt;un.echo.sequence);<br />}<br /><br /><br /></pre>